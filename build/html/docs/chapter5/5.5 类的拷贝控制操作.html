

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>5.5 类的拷贝控制操作 &mdash; C++语法笔记 v1.0 文档</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="5.6 类的继承与多态" href="5.6%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81.html" />
    <link rel="prev" title="5.4 类的构造函数" href="5.4%20%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> C++语法笔记
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter1/index.html">第1章 变量与基本类型</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第5章类</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="5.1%20%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98.html">5.1 类的成员</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.2%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98.html">5.2 类的静态成员</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.3%20%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.html">5.3 类的访问控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.4%20%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html">5.4 类的构造函数</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.5 类的拷贝控制操作</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">拷贝构造函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">1. 定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">2. 合成拷贝构造函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">3. 调用拷贝构造函数的场景：拷贝初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">拷贝赋值运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">1. 定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">2. 合成拷贝赋值运算符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">析构函数</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">1. 定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">2. 调用析构函数的场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">3. 合成析构函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id14">三/五法则</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">1. 自定义析构函数的类也需要自定义拷贝和赋值操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">2. 需要自定义拷贝操作的类也需要自定义赋值操作</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#default">=default使用合成的构造函数和拷贝控制成员</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delete">=delete删除默认构造函数和拷贝控制成员</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">1. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">2. =delete定义删除的函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#private-c-11">private拷贝控制成员（C++11新标准废弃）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">拷贝控制成员与资源管理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">1. 行为像值的类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">2. 行为像指针的类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#swap">3. swap交换操作</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id22">移动构造函数与移动赋值运算符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id23">1. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">2. 移动操作: 移动构造函数与移动赋值运算符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#noexcept">3. noexcept: 承诺移动操作不抛出异常</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">4. 移后源对象处于可析构但有效的状态</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">5. 合成的移动操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">6. 移动操作与拷贝操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">7. 移动操作与拷贝并交换赋值运算符</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="5.6%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81.html">5.6 类的继承与多态</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.7%20%E7%B1%BB%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF.html">5.7 类的多重继承与虚继承</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.8%20%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html">5.8 类的类型转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.9%20%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88.html">5.9 类成员指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.10%20union.html">5.10 union</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.11%20%E5%B5%8C%E5%A5%97%E7%B1%BB.html">5.11 嵌套类</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.12%20%E5%B1%80%E9%83%A8%E7%B1%BB.html">5.12 局部类</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">C++语法笔记</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第5章类</a> &raquo;</li>
        
      <li>5.5 类的拷贝控制操作</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/docs/chapter5/5.5 类的拷贝控制操作.md.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>5.5 类的拷贝控制操作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>简介<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>当定义一个类时，我们显式或隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么，类通过五种特殊的成员函数来控制这些操作：</p>
<ul class="simple">
<li><p>拷贝构造函数<code class="docutils literal notranslate"><span class="pre">copy</span> <span class="pre">constructor</span></code></p></li>
<li><p>拷贝赋值运算符<code class="docutils literal notranslate"><span class="pre">copy-assignment</span> <span class="pre">operator</span></code></p></li>
<li><p>移动构造函数<code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">contructor</span></code></p></li>
<li><p>移动赋值运算符<code class="docutils literal notranslate"><span class="pre">move-assignment</span> <span class="pre">operator</span></code></p></li>
<li><p>析构函数<code class="docutils literal notranslate"><span class="pre">destructor</span></code></p></li>
</ul>
<p>其中拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么，拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么，析构函数定义了当此类型对象销毁时做什么。上述五个函数统称为拷贝控制操作。</p>
</div>
<div class="section" id="id3">
<h2>拷贝构造函数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<div class="section" id="id4">
<h3>1. 定义<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：虽然我们可以定义一个接受非<code class="docutils literal notranslate"><span class="pre">const</span></code>引用的拷贝构造函数，但此参数几乎总是一个<code class="docutils literal notranslate"><span class="pre">const</span></code>引用。拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常不应该是<code class="docutils literal notranslate"><span class="pre">explicit</span></code>的。</p>
</div></blockquote>
<p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
</div>
<div class="section" id="id5">
<h3>2. 合成拷贝构造函数<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同的是，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</p>
<p>一般情况下，合成的拷贝构造函数会将其参数的非<code class="docutils literal notranslate"><span class="pre">static</span></code>成员逐个拷贝到正在创建的对象中：</p>
<ul class="simple">
<li><p>类类型成员调用其拷贝构造函数来拷贝</p></li>
<li><p>内置类型直接拷贝</p></li>
<li><p>数组：逐元素拷贝一个数组类型的元素（数组元素是类类型时调用该元素的拷贝构造函数进行拷贝）</p></li>
</ul>
</div>
<div class="section" id="id6">
<h3>3. 调用拷贝构造函数的场景：拷贝初始化<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：拷贝初始化既有可能调用拷贝构造函数也有可能调用移动构造函数（左值被拷贝而右值被移动），不过这需要类存在对应的移动构造函数。</p>
</div></blockquote>
<p>构造函数用于控制对象的初始化，那拷贝构造函数自然用于控制对象的拷贝初始化，拷贝初始化的场景包括：</p>
<ul class="simple">
<li><p>将一个对象作为实参传递给一个非引用类型的形参</p></li>
<li><p>从一个返回类型为非引用类型的函数返回一个对象</p></li>
<li><p>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p></li>
<li><p>初始化标准库容器或者调用其<code class="docutils literal notranslate"><span class="pre">insert/push</span></code>成员时容器会对其元素进行拷贝初始化（<code class="docutils literal notranslate"><span class="pre">emplace</span></code>成员创建的元素都进行直接初始化）</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">Cat</span> <span class="p">{</span>
    <span class="c1">// 默认构造函数</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cat()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 拷贝构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cat(const Cat &amp;cat)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 移动构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">Cat</span> <span class="o">&amp;&amp;</span> <span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cat(Cat &amp;&amp; cat)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 拷贝赋值运算符</span>
    <span class="n">Cat</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cat&amp; operator=(const Cat &amp;cat)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 直接初始化: 调用默认构造函数</span>
    <span class="n">Cat</span> <span class="n">cat1</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">();</span>
    <span class="c1">// 拷贝初始化: 调用拷贝构造函数</span>
    <span class="n">Cat</span> <span class="n">cat2</span><span class="p">(</span><span class="n">cat1</span><span class="p">);</span>
    <span class="c1">// 拷贝初始化: 调用拷贝构造函数</span>
    <span class="n">Cat</span> <span class="n">cat3</span> <span class="o">=</span> <span class="n">cat2</span><span class="p">;</span>
    <span class="c1">// 拷贝赋值: 调用拷贝赋值运算符</span>
    <span class="n">cat3</span> <span class="o">=</span> <span class="n">cat1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出:</span>
<span class="n">Cat</span><span class="p">()</span>
<span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span>
<span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span>
<span class="n">Cat</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span>
</pre></div>
</div>
<p>需要注意的是：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">=</span></code>不一定都是赋值（调用拷贝赋值运算符），也可能是初始化（调用拷贝构造函数）</p></li>
<li><p>拷贝初始化通常使用拷贝构造函数完成，但是有些情况下可能会使用移动构造函数来完成拷贝初始化</p></li>
</ul>
</div>
</div>
<div class="section" id="id7">
<h2>拷贝赋值运算符<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3>1. 定义<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>与类控制其对象如何初始化一样，类也可以控制其对象如何赋值。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cat</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 拷贝赋值运算符</span>
    <span class="n">Cat</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// 定义c1和c2两个Cat类型的对象</span>
<span class="n">Cat</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>
<span class="c1">// 调用Cat的拷贝赋值运算符</span>
<span class="n">c1</span> <span class="o">=</span> <span class="n">c2</span><span class="p">;</span>
</pre></div>
</div>
<blockquote>
<div><p>Tips：拷贝赋值运算符本质上是重载了赋值运算符，包括赋值运算符在内的一些运算符必须定义为成员函数。而且如果一个二元运算符是一个成员函数，其左侧运算对象就绑定到隐式的<code class="docutils literal notranslate"><span class="pre">this</span></code>参数，其右侧运算对象作为显式参数传递。赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
</div></blockquote>
</div>
<div class="section" id="id9">
<h3>2. 合成拷贝赋值运算符<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为其合成一个。它会将右侧运算对象的每个非<code class="docutils literal notranslate"><span class="pre">static</span></code>成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员则逐个赋值数组元素。</p>
</div>
</div>
<div class="section" id="id10">
<h2>析构函数<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<div class="section" id="id11">
<h3>1. 定义<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：</p>
<ul class="simple">
<li><p>析构函数不接受任何参数，因此无法被重载，一个给定类只会有唯一一个析构函数</p></li>
<li><p>构造函数中成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序初始化；析构函数中首先执行函数体然后按照成员初始化顺序的逆序销毁</p></li>
<li><p>隐式销毁一个内置指针类型的成员不会<code class="docutils literal notranslate"><span class="pre">delete</span></code>它所指向的对象（智能指针在析构阶段会自动销毁它指向的对象）</p></li>
</ul>
</div></blockquote>
<p>析构函数执行与构造函数相反的操作：</p>
<ul class="simple">
<li><p>构造函数初始化对象的非<code class="docutils literal notranslate"><span class="pre">static</span></code>数据成员，还可能做一些其他工作</p></li>
<li><p>析构函数释放对象使用的资源，并销毁对象的非<code class="docutils literal notranslate"><span class="pre">static</span></code>数据成员</p></li>
</ul>
</div>
<div class="section" id="id12">
<h3>2. 调用析构函数的场景<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
</div></blockquote>
<p>无论何时一个对象被销毁，就会调用其析构函数：</p>
<ul class="simple">
<li><p>变量离开其作用域被销毁</p></li>
<li><p>当一个对象被销毁时，其成员被销毁</p></li>
<li><p>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁</p></li>
<li><p>对于动态分配的对象，当对指向它的指针应用<code class="docutils literal notranslate"><span class="pre">delete</span></code>运算符被销毁</p></li>
<li><p>对于临时对象，当创建它的完整表达式结束时被销毁</p></li>
</ul>
</div>
<div class="section" id="id13">
<h3>3. 合成析构函数<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>当一个类未定义自己的析构函数，编译器会为它合成一个合成析构函数。类似拷贝构造函数和拷贝赋值运算符，对于某些类合成析构函数用于阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。</p>
</div>
</div>
<div class="section" id="id14">
<h2>三/五法则<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h2>
<p>C++语言并不要求我们定义全部五种拷贝控制操作：可以只定义其中一个或两个，而不必定义所有。但是这些操作通常应该被看做一个整体，只需要其中一个操作而不需要定义所有操作的情况是很少见的。</p>
<ul class="simple">
<li><p>“三法则”：针对的是较旧的C++89标准，指的是自定义析构函数的类不可使用合成拷贝构函数和合成拷贝赋值运算符，必须自定义拷贝和赋值操作（哪怕是删除的）</p></li>
<li><p>“五法则”针对的是较新的C++11标准，加入了移动构造函数和移动赋值运算符，虽然不提供移动构造函数和移动赋值运算符通常不是错误，但会失去优化的机会</p></li>
</ul>
<div class="section" id="id15">
<h3>1. 自定义析构函数的类也需要自定义拷贝和赋值操作<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：如果一个类需要自定义析构函数，我们几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。一个类需要自定义析构函数往往是因为合成析构函数不足以释放类所拥有的资源（最典型的就是指针成员），自定义拷贝构造函数和拷贝赋值运算符是为了防止指针类型成员的浅拷贝问题。</p>
</div></blockquote>
<p>假设一个类<code class="docutils literal notranslate"><span class="pre">HasPtr</span></code>在构造函数中分配动态内存，那么我们必须自定义一个析构函数来释放构造函数分配的内存（合成的析构函数不会<code class="docutils literal notranslate"><span class="pre">delete</span></code>一个指针数据成员），此时使用合成版本的拷贝构造函数和拷贝运算符会引入一个严重的错误：拷贝操作简单拷贝指针成员，这意味着多个<code class="docutils literal notranslate"><span class="pre">HasPtr</span></code>对象可能指向相同的内存。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">HasPtr</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造函数: 分配一个string的动态内存</span>
    <span class="k">explicit</span> <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// 自定义析构函数: 释放管理的string动态内存</span>
    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ps_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HasPtr</span> <span class="n">hp1</span> <span class="o">=</span> <span class="n">HasPtr</span><span class="p">(</span><span class="s">&quot;tomocat&quot;</span><span class="p">);</span>
    <span class="c1">// hp2调用默认的拷贝构造函数: 简单拷贝ps_指针的值, 从而hp1和hp2的ps_指针指向同一块内存</span>
    <span class="n">HasPtr</span> <span class="n">hp2</span> <span class="o">=</span> <span class="n">hp1</span><span class="p">;</span>

    <span class="c1">// main函数结束时调用hp1和hp2的析构函数, 导致此指针被delete两次, 这是未定义的行为</span>
    <span class="c1">// 在我的Linux机器上发生了core dumped</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>2. 需要自定义拷贝操作的类也需要自定义赋值操作<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>有一些类只需要自定义拷贝或赋值操作，而不需要自定义析构函数。假设某个类需要拷贝构造函数为每个对象分配一个独一无二的序号，除此之外这个拷贝构造函数从给定对象拷贝所有其他数据成员。我们可以肯定的是这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。</p>
</div>
</div>
<div class="section" id="default">
<h2>=default使用合成的构造函数和拷贝控制成员<a class="headerlink" href="#default" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>Tips：在类内用<code class="docutils literal notranslate"><span class="pre">=default</span></code>修饰成员的声明时，合成的函数将隐式地声明为内敛的。</p>
</div></blockquote>
<p>我们可以使用<code class="docutils literal notranslate"><span class="pre">default</span></code>来显式地要求编译器生成合成的构造函数和拷贝控制成员：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Cat</span> <span class="p">{</span>
    <span class="c1">// 合成的默认构造函数</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// 合成的拷贝构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// 合成的拷贝赋值运算符</span>
    <span class="n">Cat</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// 合成的析构函数</span>
    <span class="o">~</span><span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="delete">
<h2>=delete删除默认构造函数和拷贝控制成员<a class="headerlink" href="#delete" title="永久链接至标题">¶</a></h2>
<div class="section" id="id17">
<h3>1. 简介<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>正常来说大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是显式地还是隐式地。但是对于某些类来说这些操作没有合理的意义，在这些情况下必须采用某种机制阻止拷贝或者赋值。例如<code class="docutils literal notranslate"><span class="pre">iostream</span></code>阻止了拷贝以避免多个对象写入或者读取相同的IO缓冲。</p>
</div>
<div class="section" id="id18">
<h3>2. =delete定义删除的函数<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">=delete</span></code>通知编译器我们不希望定义这些函数成员：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">Cat</span> <span class="p">{</span>
    <span class="c1">// 使用合成的默认构造函数</span>
    <span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// 阻止拷贝构造函数</span>
    <span class="n">Cat</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="c1">// 阻止拷贝赋值运算符</span>
    <span class="n">Cat</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Cat</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="c1">// 删除的析构函数: 不允许定义该类型的变量或创建该类型的临时变量</span>
    <span class="o">~</span><span class="n">Cat</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 报错: error: use of deleted function ‘Cat::~Cat()’</span>
    <span class="n">Cat</span> <span class="n">cat</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>需要注意的是：</p>
<ul class="simple">
<li><p>我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用<code class="docutils literal notranslate"><span class="pre">=default</span></code>，但是我们可以对任何函数指定<code class="docutils literal notranslate"><span class="pre">=delete</span></code>，虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的</p></li>
<li><p>析构函数不能是删除的成员：对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类型的临时对象，不过我们可以动态分配这种类型的对象（但是不能释放这些对象）</p></li>
</ul>
</div>
</div>
<div class="section" id="private-c-11">
<h2>private拷贝控制成员（C++11新标准废弃）<a class="headerlink" href="#private-c-11" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><p>Tips：在C++11新标准下，希望组织拷贝的类应该使用<code class="docutils literal notranslate"><span class="pre">=delete</span></code>来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为<code class="docutils literal notranslate"><span class="pre">private</span></code>的。</p>
</div></blockquote>
<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为<code class="docutils literal notranslate"><span class="pre">private</span></code>来阻止拷贝的：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PrivateCopy</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
    <span class="c1">// 拷贝控制成员是private的, 因此普通用户代码无法访问</span>
    <span class="n">PrivateCopy</span><span class="p">(</span><span class="k">const</span> <span class="n">PrivateCopy</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="n">PrivateCopy</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">PrivateCopy</span><span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="n">PrivateCopy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">PrivateCopy</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>需要注意的是：</p>
<ul class="simple">
<li><p>拷贝构造函数和拷贝赋值运算符是<code class="docutils literal notranslate"><span class="pre">private</span></code>的，用户代码将不能拷贝这个类型的对象</p></li>
<li><p>友元和成员函数仍然可以拷贝对象，我们可以将这些拷贝控制成员声明为<code class="docutils literal notranslate"><span class="pre">private</span></code>但不定义他们就可以阻止友元和成员函数进行拷贝</p></li>
</ul>
<blockquote>
<div><p>Tips：声明但不定义一个成员函数是合法的，但试图访问一个未定义的成员将导致一个链接时错误。</p>
</div></blockquote>
</div>
<div class="section" id="id19">
<h2>拷贝控制成员与资源管理<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<p>通常管理类外资源的类需要通过析构函数来释放对象所分配的资源，根据“三/五原则”它也必须自定义拷贝构造函数和拷贝赋值运算符（<code class="docutils literal notranslate"><span class="pre">delete</span></code>拷贝构造函数和拷贝赋值运算符也算自定义的一种）。</p>
<p>对于管理类外资源的类，根据如何拷贝指针成员我们可以大致分为如下三类：</p>
<ul class="simple">
<li><p>既不像值也不像指针的类：<code class="docutils literal notranslate"><span class="pre">IO</span></code>类型和<code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>这种不允许拷贝和赋值的类</p></li>
<li><p>行为像值的类：标准库容器和<code class="docutils literal notranslate"><span class="pre">string</span></code>类</p></li>
<li><p>行为像指针的类：<code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code></p></li>
</ul>
<div class="section" id="id20">
<h3>1. 行为像值的类<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>为了提供类值的行为，对于类管理的资源，每个对象都应该有自己的一份拷贝。以管理<code class="docutils literal notranslate"><span class="pre">string</span></code>资源的类<code class="docutils literal notranslate"><span class="pre">HasPtr</span></code>的类而言：</p>
<ul class="simple">
<li><p>拷贝构造函数：完成<code class="docutils literal notranslate"><span class="pre">string</span></code>的拷贝而不是拷贝指针</p></li>
<li><p>析构函数：释放<code class="docutils literal notranslate"><span class="pre">string</span></code>对象</p></li>
<li><p>拷贝赋值运算符：释放对象当前的<code class="docutils literal notranslate"><span class="pre">string</span></code>，并从右侧运算对象拷贝<code class="docutils literal notranslate"><span class="pre">string</span></code></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造函数: 分配string动态内存</span>
    <span class="k">explicit</span> <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// 拷贝构造函数</span>
    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps_</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// 拷贝赋值运算符</span>
    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">// 析构函数: 释放构造函数中分配的动态内存</span>
    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ps_</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 类自定义的swap成员函数</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">HasPtr</span><span class="o">&amp;</span><span class="p">);</span>

 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 拷贝赋值运算符:</span>
<span class="c1">// 1) 组合了析构函数和拷贝构造函数: 先销毁左侧运算对象资源, 然后从右侧运算对象拷贝数据</span>
<span class="c1">// 2) 自赋值安全: 如果将一个对象赋予它自身, 赋值运算符必须能正确工作</span>
<span class="c1">// 3) 异常安全: 当异常发生时能将左侧运算对象置于一个有意义的状态</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">newp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span><span class="p">);</span>  <span class="c1">// 拷贝底层string</span>
    <span class="k">delete</span> <span class="n">ps_</span><span class="p">;</span>                             <span class="c1">// 释放本对象的旧内存</span>
    <span class="n">ps_</span> <span class="o">=</span> <span class="n">newp</span><span class="p">;</span>                             <span class="c1">// 从右侧运算对象拷贝数据到本对象</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>2. 行为像指针的类<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>令一个类展现类似指针的行为的最好方法是使用<code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>来管理类中的资源，拷贝（或赋值）一个<code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>会拷贝（或赋值）<code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>所指向的指针。<code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>类会自己记录有多少用户共享它所指向的对象，当没有用户使用对象时，<code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>类负责释放资源。</p>
</div>
<div class="section" id="swap">
<h3>3. swap交换操作<a class="headerlink" href="#swap" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：管理动态资源的类通常除了自定义拷贝控制成员外，还需要定义一个名为<code class="docutils literal notranslate"><span class="pre">swap</span></code>的函数。如果一个类定义了自己的<code class="docutils literal notranslate"><span class="pre">swap</span></code>成员函数，那么算法将使用类自定义版本，否则算法将使用标准库定义的<code class="docutils literal notranslate"><span class="pre">swap</span></code>。</p>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 交换指针而非string数据, 提高性能</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">ps_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>定义了<code class="docutils literal notranslate"><span class="pre">swap</span></code>的类通常用<code class="docutils literal notranslate"><span class="pre">swap</span></code>来定义它们的“拷贝并交换赋值运算符”，这些运算符使用了一种名为拷贝并交换<code class="docutils literal notranslate"><span class="pre">copy</span> <span class="pre">and</span> <span class="pre">swap</span></code>的技术，将左侧运算对象与右侧运算对象的一个副本进行交换：</p>
<blockquote>
<div><p>Tips：</p>
<ul class="simple">
<li><p>这种技术天生是自赋值安全且异常安全的，一方面它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的安全性，另一方面代码唯一可能抛出异常的是拷贝构造函数中的<code class="docutils literal notranslate"><span class="pre">new</span></code>表达式，如果真的抛出异常也是在我们改变左侧运算对象之前发生</p></li>
<li><p>由于接受的参数并不是一个引用，因此该参数需要进行拷贝初始化，既有可能调用拷贝构造函数（左值）也有可能调用移动构造函数（右值）</p></li>
<li><p>当类定义了移动构造函数时，拷贝并交换赋值运算符也会为该类实现一个移动赋值运算符</p></li>
</ul>
</div></blockquote>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 拷贝并交换赋值运算符既是移动赋值运算符也是拷贝赋值运算符:</span>
<span class="c1">// 1) 参数并不是一个引用: 调用拷贝/移动构造函数以值传递传入一个右侧运算对象的副本</span>
<span class="c1">// 2) 交换左侧运算对象与右侧运算对象的副本</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>  <span class="c1">// rhs现在指向本对象曾经使用过的内存</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>      <span class="c1">// rhs销毁, 从而delete了rhs中的指针</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id22">
<h2>移动构造函数与移动赋值运算符<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<div class="section" id="id23">
<h3>1. 简介<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<p>新标准一个最主要的特性是可以移动而非拷贝对象的能力，在很多情况下对象拷贝后就立即被销毁了，在这些情况下移动而非拷贝对象会大幅度提升性能。使用移动而非拷贝的另一个原因源于<code class="docutils literal notranslate"><span class="pre">IO</span></code>类或<code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>这样的类，这些类都包含不能被共享的资源（如指针或<code class="docutils literal notranslate"><span class="pre">IO</span></code>缓冲），因此这些类型的对象不能拷贝但可以移动。</p>
</div>
<div class="section" id="id24">
<h3>2. 移动操作: 移动构造函数与移动赋值运算符<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps_</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ps_</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 移动构造函数</span>
    <span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="c1">// 移动赋值运算符</span>
    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>


 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 移动构造函数:</span>
<span class="c1">// 1) 接管右侧运算对象中的资源</span>
<span class="c1">// 2) 令右侧运算对象进入析构安全的状态</span>
<span class="n">HasPtr</span><span class="o">::</span><span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 将rhs置于可析构的状态</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 移动赋值运算符:</span>
<span class="c1">// 1) 必须正确处理自赋值</span>
<span class="c1">// 2) 释放左侧运算对象的资源</span>
<span class="c1">// 3) 接管右侧运算对象中的资源</span>
<span class="c1">// 4) 令右侧运算对象进入析构安全的状态</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// 直接检测自赋值</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">ps_</span><span class="p">;</span>
        <span class="n">ps_</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span><span class="p">;</span>
        <span class="c1">// 将rhs置于可析构的状态</span>
        <span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="noexcept">
<h3>3. noexcept: 承诺移动操作不抛出异常<a class="headerlink" href="#noexcept" title="永久链接至标题">¶</a></h3>
<p>由于移动操作通常是“窃取”资源而不分配资源，因此移动操作不会抛出任何异常。当编写不抛出异常的移动构造函数和移动赋值运算符时，我们必须在类头文件的声明和定义中都指定为<code class="docutils literal notranslate"><span class="pre">noexcept</span></code>来通知标准库我们的移动操作不会抛出异常，防止标准库为了处理抛出异常的可能性而做一些浪费性能的额外工作。</p>
<p>比如标准库<code class="docutils literal notranslate"><span class="pre">vector</span></code>承诺如果我们调用<code class="docutils literal notranslate"><span class="pre">push_back()</span></code>时发生异常，则<code class="docutils literal notranslate"><span class="pre">vector</span></code>自身不会发生改变。假设<code class="docutils literal notranslate"><span class="pre">push_back()</span></code>时触发了<code class="docutils literal notranslate"><span class="pre">vector</span></code>扩容，此时<code class="docutils literal notranslate"><span class="pre">vector</span></code>会将元素从旧的堆空间复制到新申请的堆空间，考虑移动构造函数和拷贝构造函数：</p>
<ul class="simple">
<li><p>移动构造函数：假设移动构造函数未声明成<code class="docutils literal notranslate"><span class="pre">noexcept</span></code>的且移动部分而非全部元素后抛出了异常，此时使用旧空间中移后源对象的值是不安全的而新空间中未构造的元素还不存在，这种情况下不能满足<code class="docutils literal notranslate"><span class="pre">vecotr</span></code>自身不变的要求</p></li>
<li><p>拷贝构造函数：假设<code class="docutils literal notranslate"><span class="pre">vector</span></code>使用拷贝构造函数且在拷贝部分元素后发生了异常，虽然新空间中未构造的元素还不存在但旧空间的元素保持不变，<code class="docutils literal notranslate"><span class="pre">vector</span></code>可以释放新分配（但还未成功构造的）内存并返回</p></li>
</ul>
<blockquote>
<div><p>Tips：为了避免潜在的问题，诸如<code class="docutils literal notranslate"><span class="pre">push_back()</span></code>等的标准库函数除非知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存拷贝元素的过程中，它就必须使用拷贝构造函数而不是移动构造函数（这会造成一定的性能浪费）。如果希望在这些情况下对我们自定义类型对象进行移动而不是拷贝，就必须显式通过<code class="docutils literal notranslate"><span class="pre">noexcept</span></code>声明告诉标准库我们的移动构造函数是异常安全的。</p>
</div></blockquote>
</div>
<div class="section" id="id25">
<h3>4. 移后源对象处于可析构但有效的状态<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><p>Tips：在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p>
</div></blockquote>
<p>从一个对象移动数据并不会销毁此对象，但是必须确保移后源对象进入一个析构安全且有效的状态：</p>
<ul class="simple">
<li><p>析构安全：移动操作会“窃取”移后源对象的资源，析构移后源对象不应该影响其他对象数据的安全性</p></li>
<li><p>有效：移动操作必须确保移后源对象仍然是有效的（即我们可以安全地为其赋予新值或者安全地使用而不依赖当前值），需要注意的是移动操作对移后源对象中留下的值没有任何要求（移后源对象的旧值是不明确的）</p></li>
</ul>
</div>
<div class="section" id="id26">
<h3>5. 合成的移动操作<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p>只有当一个没有自定义它任何版本的拷贝构造函数（拷贝构造函数、拷贝赋值运算符或析构函数三者之一）。且类的每个非<code class="docutils literal notranslate"><span class="pre">static</span></code>数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>
</div>
<div class="section" id="id27">
<h3>6. 移动操作与拷贝操作<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>如果一个类既提供移动操作（移动构造函数和移动赋值运算符）也提供拷贝操作（拷贝构造函数和拷贝赋值运算符），那么对于拷贝操作而言，它接受<code class="docutils literal notranslate"><span class="pre">const</span></code>引用从而可以用于任何类型的实参。对于移动操作而言，它接受右值引用从而只能用于实参是非<code class="docutils literal notranslate"><span class="pre">static</span></code>右值的情形。</p>
<p>我们需要注意：</p>
<ul class="simple">
<li><p>同时提供移动操作和拷贝操作：根据精确匹配的原则，当接受右值引用时会使用移动操作而不是拷贝操作</p></li>
<li><p>只提供拷贝操作：即使接受右值引用也会调用拷贝操作</p></li>
</ul>
</div>
<div class="section" id="id28">
<h3>7. 移动操作与拷贝并交换赋值运算符<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>前面提到了“拷贝并交换赋值运算符”，当我们为<code class="docutils literal notranslate"><span class="pre">HasPtr</span></code>类定义了一个移动构造函数和拷贝并交换赋值运算符时，它实际上也会获得一个移动赋值运算符，这意味着该运算符同时实现了移动赋值运算符和拷贝赋值运算符：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">HasPtr</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
    <span class="c1">// 构造函数</span>
    <span class="k">explicit</span> <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// 拷贝构造函数</span>
    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">ps_</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;copy constructor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 移动构造函数</span>
    <span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ps_</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;move constructor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 析构函数</span>
    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ps_</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// 类自定义的swap成员函数</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">ps_</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ps_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 拷贝并交换运算符: 既是移动赋值运算符(需要定义移动构造函数)又是拷贝赋值运算符(需要定义拷贝构造函数)</span>
    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps_</span><span class="p">;</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">HasPtr</span> <span class="n">a</span><span class="p">(</span><span class="s">&quot;tomo&quot;</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>             <span class="c1">// 调用拷贝赋值运算符</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 调用移动赋值运算符</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出:</span>
<span class="n">copy</span> <span class="n">constructor</span>
<span class="n">move</span> <span class="n">constructor</span>
</pre></div>
</div>
<p>“拷贝并交换运算符”有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数（左值被拷贝，右值被移动）。因此单一的“拷贝并交换运算符”就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="5.6%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81.html" class="btn btn-neutral float-right" title="5.6 类的继承与多态" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="5.4%20%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html" class="btn btn-neutral float-left" title="5.4 类的构造函数" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2021, TOMOCAT.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>